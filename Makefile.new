# Makefile.new — Enhanced build system for Athena Prolog Engine
# Copyright © 2025 Masaya Taniguchi
# Released under the GNU General Public License v3.0

# =============================================================================
# CONFIGURATION
# =============================================================================

# Project information
PROJECT_NAME := athena
VERSION := 1.0.0
MAINTAINER := Masaya Taniguchi

# Directories
SRC_DIR := src
TEST_DIR := test
DOCS_DIR := docs
DIST_DIR := dist
BUILD_DIR := build
BENCHMARK_DIR := test/benchmarks

# Documentation
README_FILES := README.md CLAUDE.md $(DOCS_DIR)/ARCHITECTURE.md $(DOCS_DIR)/EXAMPLES.md $(DOCS_DIR)/API_REFERENCE.md

# Scheme implementations
SCHEME_IMPLS := racket gauche chicken guile chibi sagittarius gambit chez

# Common Lisp implementations  
CL_IMPLS := sbcl ccl ecl abcl

# Default implementations for testing
DEFAULT_SCHEME := racket gauche chibi
DEFAULT_CL := sbcl

# Colors for output
RED := \033[0;31m
GREEN := \033[0;32m
BLUE := \033[0;34m
YELLOW := \033[1;33m
NC := \033[0m

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# Function to check if command exists
define check_command
	@command -v $(1) >/dev/null 2>&1 || (echo "$(RED)[ERROR]$(NC) $(1) not found" && exit 1)
endef

# Function to print status messages
define print_status
	@echo "$(BLUE)[INFO]$(NC) $(1)"
endef

define print_success
	@echo "$(GREEN)[SUCCESS]$(NC) $(1)"
endef

define print_warning
	@echo "$(YELLOW)[WARNING]$(NC) $(1)"
endef

# =============================================================================
# MAIN TARGETS
# =============================================================================

.PHONY: all test clean help dev setup docs dist benchmark format lint

# Default target
all: test

# Help target
help:
	@echo "Athena Prolog Engine Build System"
	@echo "=================================="
	@echo ""
	@echo "Main Targets:"
	@echo "  all                Build and test everything (default)"
	@echo "  test               Run all tests"
	@echo "  clean              Clean build artifacts"
	@echo "  setup              Set up development environment"
	@echo "  dev                Set up development environment and run tests"
	@echo ""
	@echo "Testing Targets:"
	@echo "  test-scheme        Test all Scheme implementations"
	@echo "  test-cl            Test all Common Lisp implementations"
	@echo "  test-all           Test all implementations"
	@echo "  test-fast          Quick test with default implementations"
	@echo ""
	@echo "Individual Implementation Tests:"
	@$(foreach impl,$(SCHEME_IMPLS),echo "  test-$(impl)           Test with $(impl)";)
	@$(foreach impl,$(CL_IMPLS),echo "  test-$(impl)           Test with $(impl)";)
	@echo ""
	@echo "Development Targets:"
	@echo "  format             Format all source code"
	@echo "  lint               Run linters and static analysis"
	@echo "  docs               Generate documentation"
	@echo "  benchmark          Run performance benchmarks"
	@echo ""
	@echo "Distribution Targets:"
	@echo "  dist               Create distribution packages"
	@echo "  dist-clean         Clean distribution artifacts"
	@echo ""
	@echo "Utility Targets:"
	@echo "  setup              Set up development environment"
	@echo "  check-deps         Check for required dependencies"
	@echo "  list-impls         List available implementations"

# Development setup
dev: setup test-fast
	$(call print_success,"Development environment ready")

setup: check-deps
	$(call print_status,"Setting up development environment")
	@if command -v devbox >/dev/null 2>&1; then \
		devbox shell --config .devbox.json; \
	else \
		$(call print_warning,"devbox not found, manual setup required"); \
	fi
	@if command -v lefthook >/dev/null 2>&1; then \
		lefthook install; \
		$(call print_success,"Git hooks installed"); \
	else \
		$(call print_warning,"lefthook not found, git hooks not installed"); \
	fi

# =============================================================================
# TESTING TARGETS
# =============================================================================

# Run all tests
test: test-scheme test-cl
	$(call print_success,"All tests completed")

# Quick test with default implementations
test-fast:
	$(call print_status,"Running quick tests with default implementations")
	@$(foreach impl,$(DEFAULT_SCHEME),$(MAKE) test-$(impl) || exit 1;)
	@$(foreach impl,$(DEFAULT_CL),$(MAKE) test-$(impl) || exit 1;)
	$(call print_success,"Quick tests completed")

# Test all Scheme implementations
test-scheme:
	$(call print_status,"Testing all Scheme implementations")
	@failed=0; \
	for impl in $(SCHEME_IMPLS); do \
		if $(MAKE) test-$$impl; then \
			echo "$(GREEN)[PASS]$(NC) $$impl"; \
		else \
			echo "$(RED)[FAIL]$(NC) $$impl"; \
			failed=$$((failed + 1)); \
		fi; \
	done; \
	if [ $$failed -eq 0 ]; then \
		$(call print_success,"All Scheme tests passed"); \
	else \
		$(call print_warning,"$$failed Scheme implementation(s) failed"); \
	fi

# Test all Common Lisp implementations
test-cl:
	$(call print_status,"Testing all Common Lisp implementations")
	@failed=0; \
	for impl in $(CL_IMPLS); do \
		if $(MAKE) test-$$impl; then \
			echo "$(GREEN)[PASS]$(NC) $$impl"; \
		else \
			echo "$(RED)[FAIL]$(NC) $$impl"; \
			failed=$$((failed + 1)); \
		fi; \
	done; \
	if [ $$failed -eq 0 ]; then \
		$(call print_success,"All Common Lisp tests passed"); \
	else \
		$(call print_warning,"$$failed Common Lisp implementation(s) failed"); \
	fi

# Individual Scheme implementation tests
test-racket:
	@if command -v racket >/dev/null 2>&1; then \
		$(call print_status,"Testing with Racket"); \
		racket $(TEST_DIR)/test.rkt; \
	else \
		$(call print_warning,"Racket not found, skipping"); \
		exit 1; \
	fi

test-gauche:
	@if command -v gosh >/dev/null 2>&1; then \
		$(call print_status,"Testing with Gauche"); \
		gosh -r 7 -I $(SRC_DIR) $(TEST_DIR)/test.7.scm; \
	else \
		$(call print_warning,"Gauche not found, skipping"); \
		exit 1; \
	fi

test-chicken:
	@if command -v csi >/dev/null 2>&1; then \
		$(call print_status,"Testing with Chicken Scheme"); \
		csi -require-extension r7rs -include-path $(SRC_DIR) -eval '(include "$(SRC_DIR)/prolog.sld")' -script $(TEST_DIR)/test.7.scm; \
	else \
		$(call print_warning,"Chicken Scheme not found, skipping"); \
		exit 1; \
	fi

test-guile:
	@if command -v guile >/dev/null 2>&1; then \
		$(call print_status,"Testing with Guile"); \
		guile --fresh-auto-compile -x .sld -L $(SRC_DIR) $(TEST_DIR)/test.7.scm; \
	else \
		$(call print_warning,"Guile not found, skipping"); \
		exit 1; \
	fi

test-chibi:
	@if command -v chibi-scheme >/dev/null 2>&1; then \
		$(call print_status,"Testing with Chibi Scheme"); \
		chibi-scheme -I $(SRC_DIR) -I $(TEST_DIR) $(TEST_DIR)/test.7.scm; \
	else \
		$(call print_warning,"Chibi Scheme not found, skipping"); \
		exit 1; \
	fi

test-sagittarius:
	@if command -v sagittarius >/dev/null 2>&1; then \
		$(call print_status,"Testing with Sagittarius"); \
		sagittarius --clean-cache --disable-cache --loadsuffix=.sld --standard=7 --loadpath=$(SRC_DIR) $(TEST_DIR)/test.7.scm; \
	else \
		$(call print_warning,"Sagittarius not found, skipping"); \
		exit 1; \
	fi

test-chez:
	@if command -v scheme >/dev/null 2>&1; then \
		$(call print_status,"Testing with Chez Scheme"); \
		scheme --libdirs $$CHEZSCHEMELIBDIRS:$$PWD/$(SRC_DIR) --script $(TEST_DIR)/test.6.scm; \
	else \
		$(call print_warning,"Chez Scheme not found, skipping"); \
		exit 1; \
	fi

test-gambit:
	@if command -v gsi >/dev/null 2>&1; then \
		$(call print_status,"Testing with Gambit"); \
		gsi -:r7rs $(SRC_DIR)/ $(TEST_DIR)/test.7.scm; \
	else \
		$(call print_warning,"Gambit not found, skipping"); \
		exit 1; \
	fi

# Individual Common Lisp implementation tests
test-sbcl:
	@if command -v sbcl >/dev/null 2>&1; then \
		$(call print_status,"Testing with SBCL"); \
		cd $(CURDIR) && sbcl --eval "(require :asdf)" \
			--eval "(push #P\".\" asdf:*central-registry*)" \
			--eval "(handler-bind ((sb-ext:package-lock-violation (lambda (c) (declare (ignore c)) (continue)))) (asdf:test-system :prolog))" \
			--quit; \
	else \
		$(call print_warning,"SBCL not found, skipping"); \
		exit 1; \
	fi

test-ccl:
	@if command -v ccl >/dev/null 2>&1; then \
		$(call print_status,"Testing with CCL"); \
		cd $(CURDIR) && ccl --eval "(require :asdf)" \
			--eval "(push #P\".\" asdf:*central-registry*)" \
			--eval "(asdf:test-system :prolog)" \
			--eval "(quit)"; \
	else \
		$(call print_warning,"CCL not found, skipping"); \
		exit 1; \
	fi

test-ecl:
	@if command -v ecl >/dev/null 2>&1; then \
		$(call print_status,"Testing with ECL"); \
		cd $(CURDIR) && ecl --eval "(require :asdf)" \
			--eval "(push #P\".\" asdf:*central-registry*)" \
			--eval "(asdf:test-system :prolog)" \
			--eval "(quit)"; \
	else \
		$(call print_warning,"ECL not found, skipping"); \
		exit 1; \
	fi

test-abcl:
	@if command -v abcl >/dev/null 2>&1; then \
		$(call print_status,"Testing with ABCL"); \
		cd $(CURDIR) && abcl --eval "(require :asdf)" \
			--eval "(push #P\".\" asdf:*central-registry*)" \
			--eval "(asdf:test-system :prolog)" \
			--eval "(quit)"; \
	else \
		$(call print_warning,"ABCL not found, skipping"); \
		exit 1; \
	fi

# =============================================================================
# DEVELOPMENT TARGETS
# =============================================================================

# Format source code
format:
	$(call print_status,"Formatting source code")
	@if command -v schemat >/dev/null 2>&1; then \
		find $(SRC_DIR) $(TEST_DIR) -type f \( -name '*.scm' -o -name '*.sld' -o -name '*.rkt' -o -name '*.sls' \) \
			-exec sh -c 'echo "Formatting {}"; schemat < "{}" | sponge "{}"' \; ; \
		$(call print_success,"Scheme files formatted"); \
	else \
		$(call print_warning,"schemat not found, skipping Scheme formatting"); \
	fi
	@if command -v cl-format >/dev/null 2>&1; then \
		find $(SRC_DIR) $(TEST_DIR) -name '*.lisp' -exec cl-format {} \; ; \
		$(call print_success,"Common Lisp files formatted"); \
	elif command -v emacs >/dev/null 2>&1; then \
		find $(SRC_DIR) $(TEST_DIR) -name '*.lisp' -exec emacs --batch {} --eval '(indent-region (point-min) (point-max))' -f save-buffer \; ; \
		$(call print_success,"Common Lisp files formatted with Emacs"); \
	else \
		$(call print_warning,"No Common Lisp formatter found"); \
	fi

# Lint and static analysis
lint:
	$(call print_status,"Running linters and static analysis")
	@# Check for common issues in Scheme files
	@find $(SRC_DIR) $(TEST_DIR) -name '*.scm' -o -name '*.sld' -o -name '*.rkt' | while read file; do \
		echo "Checking $$file"; \
		grep -n "TODO\|FIXME\|XXX" "$$file" || true; \
	done
	@# Check for common issues in Lisp files
	@find $(SRC_DIR) $(TEST_DIR) -name '*.lisp' | while read file; do \
		echo "Checking $$file"; \
		grep -n "TODO\|FIXME\|XXX" "$$file" || true; \
	done
	$(call print_success,"Linting completed")

# Generate documentation
docs:
	$(call print_status,"Generating documentation")
	@mkdir -p $(BUILD_DIR)/docs
	@if command -v pandoc >/dev/null 2>&1; then \
		pandoc $(DOCS_DIR)/ARCHITECTURE.md -o $(BUILD_DIR)/docs/ARCHITECTURE.html; \
		pandoc $(DOCS_DIR)/EXAMPLES.md -o $(BUILD_DIR)/docs/EXAMPLES.html; \
		pandoc $(DOCS_DIR)/API_REFERENCE.md -o $(BUILD_DIR)/docs/API_REFERENCE.html; \
		pandoc README.md -o $(BUILD_DIR)/docs/README.html; \
		$(call print_success,"HTML documentation generated"); \
	else \
		$(call print_warning,"pandoc not found, copying markdown files"); \
		cp $(DOCS_DIR)/*.md $(BUILD_DIR)/docs/; \
		cp README.md $(BUILD_DIR)/docs/; \
	fi

# Run performance benchmarks
benchmark:
	$(call print_status,"Running performance benchmarks")
	@if [ -f $(BENCHMARK_DIR)/run-benchmarks.sh ]; then \
		$(BENCHMARK_DIR)/run-benchmarks.sh; \
	else \
		$(call print_warning,"Benchmark script not found"); \
	fi

# =============================================================================
# DISTRIBUTION TARGETS
# =============================================================================

# Create distribution packages
dist: clean docs
	$(call print_status,"Creating distribution packages")
	@mkdir -p $(DIST_DIR)
	
	# Create source distribution
	@tar -czf $(DIST_DIR)/$(PROJECT_NAME)-$(VERSION)-src.tar.gz \
		--exclude='$(DIST_DIR)' \
		--exclude='$(BUILD_DIR)' \
		--exclude='.git' \
		--exclude='*.log' \
		.
	
	# Create documentation distribution
	@if [ -d $(BUILD_DIR)/docs ]; then \
		tar -czf $(DIST_DIR)/$(PROJECT_NAME)-$(VERSION)-docs.tar.gz -C $(BUILD_DIR) docs; \
	fi
	
	$(call print_success,"Distribution packages created in $(DIST_DIR)")

dist-clean:
	$(call print_status,"Cleaning distribution artifacts")
	@rm -rf $(DIST_DIR)
	$(call print_success,"Distribution artifacts cleaned")

# =============================================================================
# UTILITY TARGETS
# =============================================================================

# Check for required dependencies
check-deps:
	$(call print_status,"Checking dependencies")
	@echo "Checking for required tools..."
	@command -v make >/dev/null 2>&1 || (echo "$(RED)[ERROR]$(NC) make not found" && exit 1)
	@echo "$(GREEN)[OK]$(NC) make found"
	
	@echo "Checking for Scheme implementations:"
	@$(foreach impl,$(SCHEME_IMPLS), \
		if command -v $(impl) >/dev/null 2>&1; then \
			echo "$(GREEN)[OK]$(NC) $(impl) found"; \
		else \
			echo "$(YELLOW)[SKIP]$(NC) $(impl) not found"; \
		fi;)
	
	@echo "Checking for Common Lisp implementations:"
	@$(foreach impl,$(CL_IMPLS), \
		if command -v $(impl) >/dev/null 2>&1; then \
			echo "$(GREEN)[OK]$(NC) $(impl) found"; \
		else \
			echo "$(YELLOW)[SKIP]$(NC) $(impl) not found"; \
		fi;)
	
	@echo "Checking for optional tools:"
	@if command -v schemat >/dev/null 2>&1; then \
		echo "$(GREEN)[OK]$(NC) schemat found (code formatting)"; \
	else \
		echo "$(YELLOW)[SKIP]$(NC) schemat not found (code formatting)"; \
	fi
	
	@if command -v pandoc >/dev/null 2>&1; then \
		echo "$(GREEN)[OK]$(NC) pandoc found (documentation)"; \
	else \
		echo "$(YELLOW)[SKIP]$(NC) pandoc not found (documentation)"; \
	fi
	
	@if command -v devbox >/dev/null 2>&1; then \
		echo "$(GREEN)[OK]$(NC) devbox found (development environment)"; \
	else \
		echo "$(YELLOW)[SKIP]$(NC) devbox not found (development environment)"; \
	fi

# List available implementations
list-impls:
	@echo "Available Scheme implementations:"
	@$(foreach impl,$(SCHEME_IMPLS), \
		if command -v $(impl) >/dev/null 2>&1; then \
			echo "  $(GREEN)✓$(NC) $(impl)"; \
		else \
			echo "  $(RED)✗$(NC) $(impl)"; \
		fi;)
	
	@echo "Available Common Lisp implementations:"
	@$(foreach impl,$(CL_IMPLS), \
		if command -v $(impl) >/dev/null 2>&1; then \
			echo "  $(GREEN)✓$(NC) $(impl)"; \
		else \
			echo "  $(RED)✗$(NC) $(impl)"; \
		fi;)

# Clean build artifacts
clean:
	$(call print_status,"Cleaning build artifacts")
	@rm -rf $(BUILD_DIR)
	@rm -f *.log $(TEST_DIR)/*.log
	@find . -name "*.fasl" -delete 2>/dev/null || true
	@find . -name "*.so" -delete 2>/dev/null || true
	@find . -name "*~" -delete 2>/dev/null || true
	$(call print_success,"Build artifacts cleaned")

# Clean everything including distribution
clean-all: clean dist-clean
	$(call print_status,"Cleaning everything")
	@rm -rf .devbox
	$(call print_success,"Everything cleaned")

# =============================================================================
# CONTINUOUS INTEGRATION TARGETS
# =============================================================================

# CI-friendly test target
ci-test:
	$(call print_status,"Running CI tests")
	@$(MAKE) test-fast
	@if [ "$$CI_FULL_TEST" = "true" ]; then \
		$(MAKE) test; \
	fi

# CI-friendly benchmark target
ci-benchmark:
	$(call print_status,"Running CI benchmarks")
	@if [ -f $(BENCHMARK_DIR)/run-benchmarks.sh ]; then \
		BENCHMARK_IMPLEMENTATIONS="sbcl racket" $(BENCHMARK_DIR)/run-benchmarks.sh; \
	fi

# =============================================================================
# SPECIAL TARGETS
# =============================================================================

# Upgrade build system (replace old Makefile)
upgrade:
	$(call print_status,"Upgrading build system")
	@if [ -f Makefile ] && [ "$(CURDIR)/Makefile" != "$(CURDIR)/Makefile.new" ]; then \
		cp Makefile Makefile.backup; \
		cp Makefile.new Makefile; \
		$(call print_success,"Build system upgraded (backup saved as Makefile.backup)"); \
	else \
		$(call print_warning,"No upgrade needed or already using new Makefile"); \
	fi

# Show project information
info:
	@echo "Project: $(PROJECT_NAME)"
	@echo "Version: $(VERSION)"
	@echo "Maintainer: $(MAINTAINER)"
	@echo "Source directory: $(SRC_DIR)"
	@echo "Test directory: $(TEST_DIR)"
	@echo "Documentation directory: $(DOCS_DIR)"
	@echo "Build directory: $(BUILD_DIR)"
	@echo "Distribution directory: $(DIST_DIR)"

# Mark targets as not files
.PHONY: $(SCHEME_IMPLS:%=test-%) $(CL_IMPLS:%=test-%) ci-test ci-benchmark upgrade info